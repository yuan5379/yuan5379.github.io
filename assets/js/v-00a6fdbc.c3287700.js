"use strict";(self.webpackChunkdemo1=self.webpackChunkdemo1||[]).push([[572],{389:(e,i,a)=>{a.r(i),a.d(i,{data:()=>r});const r={key:"v-00a6fdbc",path:"/%E5%B0%8F%E7%A8%8B%E5%BA%8F/2023/20230205.html",title:"分包异步化",lang:"zh-CN",frontmatter:{title:"分包异步化",date:"2023-02-05T00:00:00.000Z",tags:["小程序"],categories:["小程序"]},excerpt:"",headers:[{level:2,title:"性能优化方案",slug:"性能优化方案",children:[]},{level:2,title:"分析",slug:"分析",children:[]},{level:2,title:"解决方案",slug:"解决方案",children:[{level:3,title:"方案 1：分包异步化",slug:"方案-1-分包异步化",children:[]},{level:3,title:"方案 2：分包插件异步化",slug:"方案-2-分包插件异步化",children:[]},{level:3,title:"顶层 await",slug:"顶层-await",children:[]},{level:3,title:"基础库兼容性",slug:"基础库兼容性",children:[]}]},{level:2,title:"总结",slug:"总结",children:[]}],git:{updatedTime:null,contributors:[]}}},9677:(e,i,a)=>{a.r(i),a.d(i,{default:()=>k});var r=a(6252);const o=(0,r.uE)('<div class="custom-container tip"><p class="custom-container-title">TIP</p><p>我们在开发小程序中，经过不断迭代，代码包会越来越大，就有可能超过大小限制，无法上传代码，本文摘自 货拉拉技术 公众号，学习分包异步化</p></div><h2 id="性能优化方案" tabindex="-1"><a class="header-anchor" href="#性能优化方案" aria-hidden="true">#</a> 性能优化方案</h2><p>微信官方建议性能优化中关于代码体积优化[1]有以下 4 个方向：</p><p>1.<strong>合理使用分包加载</strong></p><p>非主包资源都可以放到分包中，保证主包资源最快时间让用户可以访问，分包的资源可以按照重要性开启分包预下载[2]。</p><p>2.<strong>避免非必要的全局自定义组件和插件</strong></p><p>如题，非必要（组件功能单一、只有 1 个页面引入等）就不要把组件写在主包，拆进分包。多个分包都同时引用的资源，放在分包里则不合适，分包没法直接访问另一个分包的资源，除非两个分包都已经加载过了。这个问题可以使用「分包异步化[3]」解决，这是本文重点，下文再表。</p><p>3.<strong>控制代码包内的资源文件</strong></p><p>图片、字体文件建议尽量都走 CDN，小程序的 WXSS 中图片资源没法访问本地路径，也是建议把图片资源放在 CDN 上，这些就是替换路径的工作，很简单。</p><p>4.<strong>及时清理无用代码和资源</strong></p><p>删代码，还有比这更开心的事情吗。</p><h2 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h2><p>货拉拉小程序在迭代中有持续优化的动作，页面和组件能分包的基本都拆出去了，剩下都是一些拆不动的。</p>',13),l=(0,r._)("p",null,[(0,r._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"图片",originSrc:"https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar4gusuD6cf5He2t2xr9vI7MlCCMKiaJ134zj3FET9uocdIzIVVqUEnulu1FO2P6iaGXIzqO1X7ASjXg/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1",data:"aurora"}),(0,r.Uk)("主包依赖分析")],-1),n=(0,r._)("p",null,[(0,r._)("strong",null,"信息点：")],-1),s=(0,r._)("ol",null,[(0,r._)("li",null,"图片资源可以迁 CDN，预计可以 -178KB。"),(0,r._)("li",null,[(0,r._)("code",null,"vendor.js"),(0,r.Uk)(" 大，主要包含全局函数库 JS 以及主包用到的 JS 资源。")])],-1),t=(0,r._)("p",null,[(0,r._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"图片",originSrc:"https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar4gusuD6cf5He2t2xr9vI7M0XOoAoZ0Akbq7ePgx4JLA3o6J6yeofZicKu1LH4OxmMRVzJC0TWqaOw/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1",data:"aurora"}),(0,r.Uk)("vendor.js webpack analyze")],-1),c=(0,r.uE)('<p>由上图简单分析可以得出，需要移除 <code>tim-wx.js</code>，这是腾讯 IMSDK，主包依赖，需要在主包进行 SDK 初始化登录，无法拆进分包。</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><p>基于以上分析，2 个关键信息：</p><ol><li>\\1. 为使用 IMSDK 提供的登录 API，<strong>腾讯 IMSDK 必须在小程序主包初始化</strong>。</li><li>\\2. IMSDK 大小是 420KB，代码已经是压缩过的，无法 Tree Shaking。</li></ol><h3 id="方案-1-分包异步化" tabindex="-1"><a class="header-anchor" href="#方案-1-分包异步化" aria-hidden="true">#</a> 方案 1：分包异步化</h3><blockquote><p>在小程序中，不同的分包对应不同的下载单元；因此，除了非独立分包可以依赖主包外，分包之间不能互相使用自定义组件或进行 <code>require</code>。「分包异步化」特性将允许通过一些配置和新的接口，使部分跨分包的内容可以等待下载后异步使用，从而一定程度上解决这个限制。</p></blockquote><p>如果小程序使用的是原生语法，可以使用「方案 1 」。如使用三方框架构建，例如：Uniapp、Taro 等，暂无法直接使用「方案 1」 ，或者说使用方式太过繁琐，不建议在生产使用。</p><p>跟着微信官方文档[4]编写<code>Demo</code>:</p><ol><li>\\1. 首先把 <code>tim-wx-sdk</code> 放进分包里面</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// subPackageA/index.jsimport TIM from &#39;tim-wx-sdk&#39;;export default TIM;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>2.封装一下 utils，在主包使用</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// utils/im.jslet TIM = {};require  .async(&#39;subPackageA/index&#39;)  .then((mod) =&gt; {    TIM = mod;  })  .catch(({ mod, errMsg }) =&gt; {    console.error(`subPackageA path: ${mod}, ${errMsg}`);  });// 导出该 SDKexport { TIM };\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>3.在主包使用，因为 <code>require.async</code> 是异步函数，要注意使用 <code>TIM</code> 的时机，必须是异步回调之后才能执行，运行 Demo 的时候可以先延时用来验证。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// app.jsimport { TIM } from &#39;@/utils/im&#39;;// 先延时等待 require.async 运行结束setTimeout(() =&gt; {  TIM.login({    userID: &#39;xxxxx&#39;,    userSig: &#39;userSig&#39;,  });}, 3000);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>4.运行，毫无意外，它报错了。</p>',15),d=(0,r._)("p",null,[(0,r._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"图片",originSrc:"https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar4gusuD6cf5He2t2xr9vI7MVTuLjvOictcYbAySVXtBb9cS3EbnXgVhNyEOXYNiaZib5ibRL6QBaxoSZw/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1",data:"aurora"}),(0,r.Uk)("运行错误")],-1),p=(0,r.uE)('<p><strong>根本原因：</strong> <code>module.exports、require</code> 属于 <code>CommonJS</code> 语法，<code>CommonJS</code> 是 <code>Node.js</code> 采用的模块化规范，而浏览器环境下不支持该语法，所以没有这些变量。所以，Uniapp 编译打包的时候会把 <code>require</code> 编译成 <code>__webpack_require__</code>，而微信小程序运行宿主环境并没有 <code>__webpack_require__</code> 这个方法，所以报错。</p><p>而 <code>require</code> 微信小程序环境是支持直接运行的，不需要经过编译，我们只需要让 Uniapp 框架不编译 <code>require.async</code> 这个函数即可，经过编写各种 demo 和 Issues[5] 查询，得出以下结论：</p><ol><li>\\1. Uniapp 官方编译脚本还未计划支持该小程序特性。</li><li>\\2. <code>non_webpack_require</code> 方案也涉及到打包脚本的一些改动，理解起来也很复杂，不适宜在生产环境中大改特改。</li></ol><p><strong>三方框架无法直接使用分包异步化，微信原生语法无影响。如一定要在第三方框架中使用「异步化」这个特性，可以使用「方案 2」。</strong></p><h3 id="方案-2-分包插件异步化" tabindex="-1"><a class="header-anchor" href="#方案-2-分包插件异步化" aria-hidden="true">#</a> 方案 2：分包插件异步化</h3><blockquote><p>微信小程序提供插件能力，具体功能可以参考官方文档[6]。<code>requirePlugin</code> 是微信官方提供给插件之间互相调用的一个方法。</p></blockquote><p><code>requirePlugin</code> 官方用法示例：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 使用回调函数风格的调用requirePlugin(  &#39;live-player-plugin&#39;,  (livePlayer) =&gt; {    console.log(livePlayer.getPluginVersion());  },  ({ mod, errMsg }) =&gt; {    console.error(`path: ${mod}, ${errMsg}`);  },);// 或者使用 Promise 风格的调用requirePlugin  .async(&#39;live-player-plugin&#39;)  .then((livePlayer) =&gt; {    console.log(livePlayer.getPluginVersion());  })  .catch(({ mod, errMsg }) =&gt; {    console.error(`path: ${mod}, ${errMsg}`);  });\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如上，加载插件用的是 <code>requirePlugin</code>，<code>Webpack</code> 打包不会编译这个方法。</p><p>回溯一下「方案一」中遇到的问题是：<code>require</code> 会被 <code>Webpack</code> 打包，编译成 <code>__webpack_require__</code>，所以造成小程序宿主环境没有 <code>require</code> 分包的能力。</p><p>「方案二」的解决思路：微信官方提供的 <code>requirePlugin</code>，<code>Webpack</code> 不会进行编译，则可以正常访问小程序宿主环境的的 <code>requirePlugin</code> API，从而达成异步加载异步的目的。</p><ol><li>\\1. 既然要插件，先去微信官方注册一个插件，这部分可以搜官方文档，主要代码如下：</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// xxx-plugin/index.js// 插件代码只是加载 SDK，并且导出import TIM from &#39;tim-wx-sdk&#39;;module.exports = {  TIM,};\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>2.在分包页面中引入插件。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{  &quot;plugins&quot;: {    &quot;xxx-plugin&quot;: {      &quot;version&quot;: &quot;dev-01055b63731de071ffb850464bd5c7b1&quot;,      &quot;provider&quot;: &quot;xxx-plugin appid&quot;    }  }}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>3.上面的 utils 封装改一下。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// utils/im.jslet TIM = null;requirePlugin  .async(&#39;xxx-plugin&#39;)  .then(({ TIM: modTIM }) =&gt; {    TIM = modTIM;  })  .catch(({ mod, errMsg }) =&gt; {    console.error(`direct-service-plugin path: ${mod}, ${errMsg}`);  });// 暴露出去export { TIM };\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>4.完事，好起来了。</p><h3 id="顶层-await" tabindex="-1"><a class="header-anchor" href="#顶层-await" aria-hidden="true">#</a> 顶层 await</h3><blockquote><p>这篇文章[7]写得很清楚了，就不搬了。</p></blockquote><p>「方案 2」确实是能够正常解决加载问题，但是引入了新的问题，上面的写法 <code>requirePlugin.async</code> 是个异步函数，调用 <code>TIM</code> 时机不同获取到的值不一样，使用 <code>utils/im</code> 的时候，还需要判断一下是否存在，还需要等待它加载。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import { TIM } from &#39;@/uitls/im&#39;;// 用的时候TIM &amp;&amp; TIM.login();\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>那比较好一点的方法是加 <code>Promise</code>，每个使用的地方等待一下</p><p>1.加载插件的封装</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// @/utils/async-load.ts/** * 加载插件的方法 * @param pluginName * @returns Promise&lt;any&gt; */export async function loadPluginPackage(pluginName: string): Promise&lt;any&gt; {  try {    // @ts-ignore    const mod = await requirePlugin.async(pluginName);    return mod;  } catch ({ mod, errMsg }) {    console.error(      `loadPluginPackage &#39;${pluginName}&#39; errpr path: ${mod}, ${errMsg}`,    );    return {};  }}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>2.使用的时候</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// app.js;(async init() {  const { TIM } = await loadPluginPackage(&#39;xxx-plugin&#39;)  TIM.login({    userID: &#39;xxxxx&#39;,    userSig: &#39;userSig&#39;,  })})()\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这样还是有问题，如果有多个地方都是用这个 JS，每个地方都要写一下加载插件的方法，可以在小程序启动的时候做一次加载就可以，后面所有用到的地方都用同一个 Promise 就行。</p><p>3.更建议的方式</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// utils/im.jslet TIM = {};import { loadPluginPackage } from &#39;@/utils/async-load&#39;;const TIMSdk = loadPluginPackage(&#39;xxx-plugin&#39;);TIMSdk.then((mod) =&gt; {  TIM = mod.TIM;});// 导出出去export { TIM, TIMSdk };\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>TIMSdk，是一个默认执行一次的 Promise，加载过一次之后，后续调用 TIMSdk 拿到的都是同一个结果。</p><p>使用方式</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// app.jsimport { TIM, TIMSdk } from &#39;@/utils/im&#39;;/** * * IM初始化 */const init = async () =&gt; {  // 要用的时候 await 一下即可  await TIMSdk;  const tim = TIM.create({    SDKAppID: config.SDKAppID,  });};init();\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这样用起来很不方便，而且如果使用的地方如果二次封装，也很麻烦，目前没有很好的方法，顶层 await 是为了解决这个问题的，这个提案目前我们还用不上。</p><p>4.完美方式，顶部直接<code>await</code>，暂时用不上</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// app.jsconst { TIM } = await loadPluginPackage(&#39;xxx-plugin&#39;);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="基础库兼容性" tabindex="-1"><a class="header-anchor" href="#基础库兼容性" aria-hidden="true">#</a> 基础库兼容性</h3>',37),u=(0,r._)("p",null,[(0,r._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"图片",originSrc:"https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar4gusuD6cf5He2t2xr9vI7M3hq3FhjNcFgjSCNTo0WDavROWsQlh81Jw5wv0a0foDmQW7b4syNJRw/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1",data:"aurora"}),(0,r.Uk)("微信官方文档描述")],-1),g=(0,r._)("p",null,"「分包异步化」这个功能需要小程序基础库 2.11.2 及以上才支持，可以按照官方推荐，设置最低基础库。",-1),m=(0,r._)("p",null,[(0,r.Uk)("如果目前线上基础库设置比这个低，需要拉一下现在线上的基础库分布，看一下提高基础库会影响多少人，"),(0,r._)("strong",null,"如果比例很小，可以强行设置，提升用户体验"),(0,r.Uk)("。")],-1),x=(0,r._)("h2",{id:"总结",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),(0,r.Uk)(" 总结")],-1),b=(0,r._)("p",null,"小程序此次优化结果：",-1),h=(0,r._)("p",null,[(0,r._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"图片",originSrc:"https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar4gusuD6cf5He2t2xr9vI7ME0yLbncCHMWj1DyibpibMCFFn7Zhtt4Y0DW8BQNWXYVjap8oicAJ1gezQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1",data:"aurora"}),(0,r.Uk)("货拉拉微信小程序 4330 版本代码依赖分析")],-1),v=(0,r.uE)('<p><strong>主包大小从 1.83M 降到 1.36M，大小减少 25%。</strong></p><blockquote><p><strong>一定要注意基础库的依赖，要用这个方案，必须要把最低基础库限制拉到 2.11.2</strong>。</p></blockquote><p><strong>控制小程序代码包大小主要几个手段：</strong></p><ol><li><p>\\1. 静态资源，能走 CDN 的，全部走 CDN。</p></li><li><p>\\2. 能分包的页面或者组件，全部放到分包里面去，主包只留不能拆分的，提升分包加载速度可以使用开启分包预下载[8]。</p></li><li><p>\\3. 如果资源一定要在主包引用且大小不可控，那就使用「分包异步化」或者「分包插件异步化」来处理。「分包异步化」和「分包插件异步化」两者的选择建议：</p></li><li><ul><li>如果用的是第三方编译的小程序框架，例如： Uniapp，用不上「分包异步化」，等三方官方支持</li><li>分包插件异步化和分包异步化写法差不多，坏处是需要发一个微信小程序插件，好处是小程序是跨端编译到其它端也可以走插件这一套逻辑。</li></ul></li></ol><h4 id="引用链接" tabindex="-1"><a class="header-anchor" href="#引用链接" aria-hidden="true">#</a> 引用链接</h4><p><code>[1]</code> 代码体积优化: <em>https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start_optimizeA.html</em><code>[2]</code> 开启分包预下载: <em>https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/preload.html</em><code>[3]</code> 分包异步化: <em>https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html</em><code>[4]</code> 微信官方文档: <em>https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html</em><code>[5]</code> Issues: <em>https://github.com/dcloudio/uni-app/issues/2934</em><code>[6]</code> 官方文档: <em>https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/</em><code>[7]</code> 这篇文章: <em>https://www.bookstack.cn/read/es6-3rd/spilt.7.docs-async.md</em><code>[8]</code> 开启分包预下载: <em>https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/preload.html</em></p>',6),w={},k=(0,a(3744).Z)(w,[["render",function(e,i){return(0,r.wg)(),(0,r.iD)(r.HY,null,[o,l,n,s,t,c,d,p,u,g,m,x,b,h,v],64)}]])}}]);