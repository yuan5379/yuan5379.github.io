"use strict";(self.webpackChunkdemo1=self.webpackChunkdemo1||[]).push([[7781],{1107:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-4d7285d1",path:"/css/2023/20231120.html",title:"浏览器跨 Tab 窗口通信原理及应用实践",lang:"zh-CN",frontmatter:{title:"浏览器跨 Tab 窗口通信原理及应用实践",date:"2023-11-20T00:00:00.000Z",tags:["css"],categories:["css"]},excerpt:"",headers:[{level:2,title:"方式一：Broadcast Channel()",slug:"方式一-broadcast-channel",children:[]},{level:2,title:"方式二：SharedWorker API",slug:"方式二-sharedworker-api",children:[]},{level:2,title:"方式三：localStorage/sessionStorage",slug:"方式三-localstorage-sessionstorage",children:[]},{level:2,title:"实际应用思考",slug:"实际应用思考",children:[]},{level:2,title:"跨 Tab 窗口通信应用场景",slug:"跨-tab-窗口通信应用场景",children:[]},{level:2,title:"最后",slug:"最后",children:[]}],git:{updatedTime:null,contributors:[]}}},4949:(n,s,a)=>{a.r(s),a.d(s,{default:()=>H});var e=a(6252);const p=(0,e.uE)('<div class="custom-container tip"><p class="custom-container-title">TIP</p><p>最近，相信大家一定跨窗口通信动画刷屏了，这篇就讲讲其中比较关键的一个技术点，应用如何在多窗口下进行互相通信</p></div><p>所谓<strong>多窗口下进行互相通信，是指在浏览器中，不同窗口（包括不同标签页、不同浏览器窗口甚至不同浏览器实例）之间进行数据传输和通信的能力。</strong></p><p>当然，本文我们探讨的是<strong>纯前端的跨 Tab 页面通信</strong>，在非纯前端的方式下，我们可以借助诸如 Web Socket 等方式，藉由后端这个中间载体，进行跨页面通信。</p><p>为了实现跨窗口通信，它应该需要具备以下能力：</p><ol><li><strong>数据传输能力</strong>：能够将数据从一个窗口发送到另一个窗口，以及接收来自其他窗口的数据。</li><li><strong>实时性</strong>：能够实现实时或近实时的数据传输，以便及时更新不同窗口的内容。</li><li>安全性：确保通信过程中的数据安全，防止恶意窃取或篡改通信数据。当然，这个不是本文讨论的重点，但是是实际应用中不应该忽视的一个重点。</li></ol><h2 id="方式一-broadcast-channel" tabindex="-1"><a class="header-anchor" href="#方式一-broadcast-channel" aria-hidden="true">#</a> 方式一：Broadcast Channel()</h2><p>Broadcast Channel 是一个较新的 Web API，用于在不同的浏览器窗口、标签页或框架之间<strong>实现跨窗口通信</strong>。它基于发布-订阅模式，允许一个窗口发送消息，并由其他窗口接收。</p><p>其核心步骤如下：</p><ol><li>创建一个 BroadcastChannel 对象：在发送和接收消息之前，首先需要在每个窗口中创建一个 BroadcastChannel 对象，使用相同的频道名称进行初始化。</li><li>发送消息：通过 BroadcastChannel 对象的 postMessage() 方法，可以向频道中的所有窗口发送消息。</li><li>接收消息：通过监听 BroadcastChannel 对象的 message 事件，可以在窗口中接收到来自其他窗口发送的消息。</li></ol><p>同时，Broadcast Channel 遵循浏览器的同源策略。这意味着只有在同一个协议、主机和端口下的窗口才能正常进行通信。如果窗口不满足同源策略，将无法互相发送和接收消息。</p><p>因为有同源限制，我们需要起一个服务，这里我基于 Vite 快速起了一个 Vue 项目，简单的基于 <code>.vue</code> 文件下进行一个演示。</p><p>其核心代码非常简单：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>javascript复制代码<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;g-container&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;j-main&quot;</span><span class="token operator">&gt;</span>\n    <span class="token comment">// ...  </span>\n  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>\n\n<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">function</span> <span class="token function">createBroadcastChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      broadcastChannel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastChannel</span><span class="token punctuation">(</span><span class="token string">&#39;broadcast&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      broadcastChannel<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> handleMessage<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">function</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      broadcastChannel<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">function</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;接收到 event&#39;</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// TODO: 处理接收到信息后的逻辑</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">function</span> <span class="token function">resizeEventBind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;resize&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n         <span class="token keyword">const</span> pos <span class="token operator">=</span> <span class="token function">getCurPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token function">sendMessage</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 计算当前元素距离显示器窗口右上角的距离</span>\n    <span class="token keyword">function</span> <span class="token function">getCurPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> barHeight <span class="token operator">=</span> window<span class="token punctuation">.</span>outerHeight <span class="token operator">-</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">;</span>\n      <span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;j-main&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">const</span> rect <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 获取元素相对于屏幕左上角的 X 和 Y 坐标</span>\n      <span class="token keyword">const</span> x <span class="token operator">=</span> rect<span class="token punctuation">.</span>left <span class="token operator">+</span> window<span class="token punctuation">.</span>screenX<span class="token punctuation">;</span> <span class="token comment">// 元素左边缘相对于屏幕左边缘的距离</span>\n      <span class="token keyword">const</span> y <span class="token operator">=</span> rect<span class="token punctuation">.</span>top <span class="token operator">+</span> window<span class="token punctuation">.</span>screenY <span class="token operator">+</span> barHeight<span class="token punctuation">;</span><span class="token comment">// 元素顶部边缘相对于屏幕顶部边缘的距离</span>\n\n      <span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    \n    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      <span class="token function">createBroadcastChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token function">resizeEventBind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>\n\n<span class="token operator">&lt;</span>style lang<span class="token operator">=</span><span class="token string">&quot;scss&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br></div></div><p>这里，我们的核心逻辑在于：</p><ul><li><code>createBroadcastChannel()</code> 函数用于创建一个 BroadcastChannel 对象，并设置消息处理函数。</li><li><code>sendMessage(data)</code> 函数用于向 BroadcastChannel 发送消息。</li><li><code>handleMessage(event)</code> 函数用于处理接收到的消息。</li><li><code>resizeEventBind()</code> 函数用于监听窗口大小变化事件，并在事件发生时获取当前元素的位置信息，并通过 <code>sendMessage()</code> 函数发送位置信息到 BroadcastChannel。</li><li><code>getCurPos()</code> 函数用于计算当前元素相对于显示器窗口右上角的距离。</li></ul><p>在 <code>onMounted()</code> 生命周期钩子中，调用了 <code>createBroadcastChannel()</code> 和 <code>resizeEventBind()</code> 函数，用于在组件挂载后执行相关的初始化操作。</p><p>这样，当我们同时打开两个窗口，移动其中一个窗口，就可以向另外一个窗口发生当前窗口希望传递过去的信息，在本例子中就是 <code>#j-main</code> 元素距离显示器右上角的距离。</p><p>假设 <code>#j-main</code> 只是一个在浏览器正中心矩形，我们同时打开两边的控制台，看看会发生什么：</p>',18),t=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"img",originSrc:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70dc7630dffb46afa3ef5e95e91a67aa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1200&h=480&s=1475688&e=gif&f=189&b=fcfbf9",data:"aurora"})],-1),l=(0,e._)("p",null,[(0,e.Uk)("可以看到，如果我们同时打开两个一个的页面，当触发右边页面的 Resize，左边的页面会收到基于 "),(0,e._)("code",null,"broadcastChannel.onmessage = handleMessage"),(0,e.Uk)(" 接收到的信息，反之同理。")],-1),r=(0,e._)("p",null,"而一个完整的 Event 信息如下：",-1),o=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"img",originSrc:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/391aa03dda6046e699a6ea731d7e2bde~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1166&h=626&s=194272&e=png&b=ffffff",data:"aurora"})],-1),c=(0,e.uE)('<p>譬如，传递过来的信息放在 data 属性内、同时也可以获取当前的的 Broadcast Name 等。</p><p>基于 BroadcastChannel，就可以实现每个 Tab 内的核心信息互传， 可以得知当前在线设备数，再基于这些信息去完成我们想要的动画、交互等效果。</p><p>这里的核心点，还是：</p><ol><li>数据向其他 Tab 页面传递的能力</li><li>Tab 页面接受其他页面传递过来的数据的能力</li></ol><p>其本质就是一个<strong>数据共享池</strong>子。</p><h2 id="方式二-sharedworker-api" tabindex="-1"><a class="header-anchor" href="#方式二-sharedworker-api" aria-hidden="true">#</a> 方式二：SharedWorker API</h2><p>好，介绍完 Broadcast Channel()，我们再来看看 SharedWorker API。</p>',7),i={href:"https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FSharedWorker",target:"_blank",rel:"noopener noreferrer"},u=(0,e.Uk)("SharedWorker "),b=(0,e.Uk)("API 是 HTML5 中提供的一种多线程解决方案，它可以在多个浏览器 TAB 页面之间共享一个后台线程，从而实现跨页面通信。"),d=(0,e.uE)('<p>与其他 Worker 不同的是，SharedWorker 可以被多个浏览器 TAB 页面共享，且可以在同一域名下的不同页面之间建立连接。这意味着，多个页面可以通过 SharedWorker 实例之间的消息传递，实现跨 TAB 页面的通信。</p><p>它的实现与上面的 Broadcast Channel 非常类似，我们来看一看实际的代码：</p><div class="language-Javascript ext-Javascript line-numbers-mode"><pre class="language-Javascript"><code>Javascript复制代码&lt;template&gt;\n  &lt;div class=&quot;g-container&quot; id=&quot;j-main&quot;&gt;\n    // ...  \n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { onMounted } from &#39;vue&#39;;\n\nexport default {\n  setup() {\n    // 创建一个 SharedWorker 对象\n    let worker;\n    \n    function initWorker() {\n      // 创建一个 SharedWorker 对象\n      worker = new SharedWorker(&#39;/shared-worker.js&#39;, &#39;tabWorker&#39;);\n\n      // 监听消息事件\n      worker.port.onmessage = function (event) {\n        console.log(&#39;接收到 event&#39;, event);\n        handleMessage(event);\n      };\n    }\n    \n    function handleMessage(data) {\n      // TODO: 处理接收到信息后的逻辑\n    }\n\n    function sendMessage(data) {\n      // 发送消息\n      worker.port.postMessage(data);\n    }\n\n    function resizeEventBind() {\n      window.addEventListener(&#39;resize&#39;, () =&gt; {\n        const pos = getCurPos();\n        sendMessage(pos);\n      });\n    }\n\n    function getCurPos() {\n      const barHeight = window.outerHeight - window.innerHeight;\n      const element = document.getElementById(&#39;j-main&#39;);\n      const rect = element.getBoundingClientRect();\n\n      // 获取元素相对于屏幕左上角的 X 和 Y 坐标\n      const x = rect.left + window.screenX; // 元素左边缘相对于屏幕左边缘的距离\n      const y = rect.top + window.screenY + barHeight;// 元素顶部边缘相对于屏幕顶部边缘的距离\n\n      return [x, y];\n    }\n    \n    onMounted(() =&gt; {\n      initWorker();\n      resizeEventBind();\n    });\n\n    return {};\n  }\n};\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br></div></div><p>简单描述一下，上面也说了，跨 Tab 页通信的核心在于数据向外的发送与接收的能力：</p><ol><li><code>initWorker()</code> 方法中，使用 <code>worker = new </code><em><code>SharedWorker</code></em><code>(&#39;/shared-worker.js&#39;, &#39;tabWorker&#39;)</code> 创建了一个 <code>SharedWorker</code> <em>，</em> 后面每一个被打开的同域浏览器 TAB 页面，都是共享这个 Worker 线程，从而实现跨页面通信</li><li>基于 <code>worker.port.postMessage(data)</code>实现数据的传输</li><li>基于 <code>worker.port.onmessage = function() {}</code> 实现传输数据的监听</li></ol><p>当然，上面有引入一个 <code>/shared-worker.js</code>，这个是需要额外定义的，一个极简版本的代码如下：</p><div class="language-Javascript ext-Javascript line-numbers-mode"><pre class="language-Javascript"><code>Javascript复制代码//shared-worker.js\nconst connections = [];\n\nonconnect = function (event) {\n  var port = event.ports[0];\n  connections.push(port);\n\n  port.onmessage = function (event) {\n    // 接收到消息时，向所有连接发送该消息\n    connections.forEach(function (conn) {\n      if (conn !== port) {\n        conn.postMessage(event.data);\n      }\n    });\n  };\n\n  port.start();\n};\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>简单解析一下，下面对其进行解析：</p><ol><li>上面的代码中，定义了一个数组 connections，用于存储与 SharedWorker 建立连接的各个页面的端口对象；</li><li>onconnect 是事件处理程序，当有新的连接建立时会触发该事件；</li><li>在 onconnect 函数中，通过 event.ports[0] 获取到与 SharedWorker 建立的连接的第一个端口对象，并将其添加到 connections 数组中，表示该页面与共享 Worker 建立了连接。</li><li>在连接建立后，为每个端口对象设置了 onmessage 事件处理程序。当端口对象接收到消息时，会触发该事件处理程序。</li><li>在 onmessage 事件处理程序中，通过遍历 connections 数组，将消息发送给除当前连接端口对象之外的所有连接。这样，消息就可以在不同的浏览器 TAB 页面之间传递。</li><li>最后，通过调用 port.start() 启动端口对象，使其开始接收消息。</li></ol><p>总而言之，shared-worker.js 脚本创建了一个共享 Worker 实例，它可以接收来自不同页面的连接请求，并将接收到的消息发送给其他连接的页面。通过使用 SharedWorker API，<strong>实现跨 TAB 页面之间的通信和数据共享</strong>。</p><p>同理，我们来看看基于 Worker 的数据传输效果，同样是简化 DEMO，当 Resize 窗口时，向另外一个窗口发送当前窗口下 <code>#j-main</code> 元素的坐标：</p>',11),m=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"img",originSrc:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90c7bcba6d6d45dd8701485b8ffd1c35~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1400&h=530&s=723673&e=gif&f=124&b=fefefe",data:"aurora"})],-1),k=(0,e._)("p",null,[(0,e.Uk)("可以看到，如果我们同时打开两个一个的页面，当触发右边页面的 Resize，左边的页面会利用 "),(0,e._)("code",null,"worker.port.onmessage = function() {}"),(0,e.Uk)(" 收到基于 "),(0,e._)("code",null,"worker.port.postMessage("),(0,e._)("em",null,[(0,e._)("code",null,"data")]),(0,e._)("code",null,")"),(0,e.Uk)(" 发送的信息，反之同理。")],-1),g=(0,e._)("p",null,"而一个完整的 Event 信息如下：",-1),h=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"img",originSrc:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45d5328674c44b92a8964c33f7868853~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=767&h=448&s=76810&e=png&b=fefefe",data:"aurora"})],-1),f=(0,e._)("p",null,[(0,e.Uk)("可以看到，在 SharedWorker 方式中，传输数据与 Broadcast Channel 是一样的，都是利用 "),(0,e._)("code",null,"Message Event"),(0,e.Uk)("。简单对比一下：")],-1),v=(0,e._)("ol",null,[(0,e._)("li",null,[(0,e.Uk)("SharedWorker 通过在多个Tab页面之间共享相同的 Worker 实例，方便地共享数据和状态，SharedWorker 需要多定义一个 "),(0,e._)("code",null,"shared-worker.js"),(0,e.Uk)(";")]),(0,e._)("li",null,"Broadcast Channel 通过向所有订阅同一频道的 Tab 页面广播消息，实现广播式的通信。")],-1),w=(0,e._)("p",null,"兼容性方面，到今天(2023-11-26)，broadcast Channel 看着是兼容性更好的方式：",-1),y=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"img",originSrc:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72eb343508d4ba8b9a24c050ef0fd61~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1829&h=395&s=178894&e=png&b=eddfc8",data:"aurora"})],-1),j=(0,e.uE)('<p>另外，需要注意的是，两个方法都使用了 <code>postMessage</code> 方法。<code>window.postMessage()</code> 方法可以安全地实现跨源通信。并且，本质上而言，单独使用 <code>postMessage</code> 就可以实现跨 Tab 通信。</p><p>但是，单独使用 <code>postMessage</code> 适合简单的点对点通信。在更复杂的场景中，Broadcast Channel 和 SharedWorker 提供更强大的机制，可简化通信逻辑，有更广泛的通信范围和生命周期管理。Broadcast Channel 的通信范围是所有订阅该频道的窗口，而 SharedWorker 可在多个窗口之间共享状态和通信。</p><h2 id="方式三-localstorage-sessionstorage" tabindex="-1"><a class="header-anchor" href="#方式三-localstorage-sessionstorage" aria-hidden="true">#</a> 方式三：localStorage/sessionStorage</h2><p>OK，最后一种跨 Tab 窗口通信的方式是利用 <code>localStorage</code> 、<code>sessionStorage</code> 本地化存储 API 以及的 <code>storage</code> 事件。</p><p>与上面 Broadcast Channel、SharedWorker 稍微不同的地方在于：</p><ol><li><code>localStorage</code> 方式，利用了本地浏览器存储，实现了同域下的数据共享；</li><li><code>localStorage</code> 方式，基于 <code>window.addEventListener(&#39;storage&#39;, </code><em><code>function</code></em><code>(</code><em><code>event</code></em><code>) {})</code>事件实现了 localStore 变化时候的数据监听；</li></ol><p>简单看看代码：</p><div class="language-Javascript ext-Javascript line-numbers-mode"><pre class="language-Javascript"><code>Javascript复制代码&lt;template&gt;\n  &lt;div class=&quot;g-container&quot; id=&quot;j-main&quot;&gt;\n    // ...  \n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { ref, reactive, computed, onMounted } from &#39;vue&#39;;\n\nexport default {\n  setup() {\n    function initLocalStorage() {\n      let tabArray = JSON.parse(localStorage.getItem(&#39;tab_array&#39;));\n      if (!tabArray) {\n        const tabIndex = 1;\n        id = tabIndex;\n        localStorage.setItem(&#39;tab_array&#39;, JSON.stringify([tabIndex]));\n      } else {\n        const tabIndex = tabArray[tabArray.length - 1] + 1;\n        id = tabIndex;\n        const newTabArray = [...tabArray, tabIndex];\n        localStorage.setItem(&#39;tab_array&#39;, JSON.stringify(newTabArray));\n      }\n    }\n\n    function setLocalStorage(data) {\n      localStorage.setItem(`tab_index_${id}`, JSON.stringify(data));\n    }\n\n    function handleMessage(data) {\n      const rArray = JSON.parse(data);\n      remoteX.value = rArray[0];\n      remoteY.value = rArray[1];\n    }\n\n    function resizeEventBind() {\n      window.addEventListener(&#39;resize&#39;, () =&gt; {\n         const pos = getCurPos();\n         setLocalStorage(pos);\n      });\n \n      window.addEventListener(&#39;storage&#39;, (event) =&gt; {\n        console.log(&#39;localStorage 变化了！&#39;, event);\n        console.log(&#39;键名：&#39;, event.key);\n        console.log(&#39;变化前的值：&#39;, event.oldValue);\n        console.log(&#39;变化后的值：&#39;, event.newValue);\n        handleMessage(event.newValue);\n      });\n    }\n\n    function getCurPos() {\n      const barHeight = window.outerHeight - window.innerHeight;\n      const element = document.getElementById(&#39;j-main&#39;);\n      const rect = element.getBoundingClientRect();\n\n      // 获取元素相对于屏幕左上角的 X 和 Y 坐标\n      const x = rect.left + window.screenX; // 元素左边缘相对于屏幕左边缘的距离\n      const y = rect.top + window.screenY + barHeight;// 元素顶部边缘相对于屏幕顶部边缘的距离\n\n      return [x, y];\n    }\n    \n    onMounted(() =&gt; {\n      initLocalStorage();\n      resizeEventBind();\n    });\n\n    return {};\n  }\n};\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br></div></div><p>同样的简单解析一下：</p><ol><li>每次页面初始化时，都会首先有一个 <code>initLocalStorage</code> 过程，用于给当前页面一个唯一 ID 标识，并且存入 localStorage 中</li><li>每次页面 resize，将当前页面元素 <code>#j-main</code> 的坐标值，通过 ID 标识当 Key，存入 localStorage 中</li><li>其他页面，通过 <code>window.addEventListener(&#39;storage&#39;, (</code><em><code>event</code></em><code>)</code><em><code>=&gt;</code></em> <code>{})</code> 监听 localStorage 的变化</li></ol><p>交互传输结果，与上述两个动图是一致的，就不额外贴图了，但是基于 <code>storage</code> 事件传输的值有点不一样，我们展开看看：</p>',11),S=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"img",originSrc:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4449e6523e0a486aa43cf77afdcd3150~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1412&h=543&s=213774&e=png&b=fffefe",data:"aurora"})],-1),_=(0,e.uE)("<p>我们通过 <code>window.addEventListener(&#39;storage&#39;, (</code><em><code>event</code></em><code>)</code><em><code>=&gt;</code></em> <code>{})</code> ，可以拿到此次变化的 localStorage key 是什么，前值 <code>oldValue</code> 与 <code>newValue</code> 等等。</p><p>当然，由于 <code>localStorage</code> 存储过程只能是字符串，在读取的时候需要利用 <code>JSON.stringify</code> 和 <code>JSON.parse</code> 额外处理一层，调试的时候需要注意。</p><p>虽然看起来这种方式最不优雅，但是结合兼容性一起看， localstorage 反而是兼容性最好的方式。在数据量较小的时候，性能相差不会太大，反而可能是更好的选择。</p><p>我基于上面三种方式：Broadcast Channel、SharedWorker 与 localStorage，都实现了一遍下面这个跨 Tab 页的 CSS 联动动画：</p>",4),B=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"img",originSrc:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/144634087b10473d932baa64503b7ade~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1200&h=773&s=7295062&e=gif&f=238&b=060606",data:"aurora"})],-1),C=(0,e.Uk)("三种方式的代码都不多，感兴趣的可以戳这里："),T={href:"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchokcoco%2FbroadcastAnimation",target:"_blank",rel:"noopener noreferrer"},W=(0,e.Uk)("Github - broadcastAnimation"),z=(0,e.uE)('<h2 id="实际应用思考" tabindex="-1"><a class="header-anchor" href="#实际应用思考" aria-hidden="true">#</a> 实际应用思考</h2><p>当然，上面的实现其实有很大一个瑕疵。</p><p>那就是我们只顾着实现通信，没有考虑实际应用中的一些实际问题：</p><ol><li>如何确定何时开始通信？</li><li>Tab 页频繁的开关，如何知道当前还有多少页面处于打开状态？</li></ol><p>基于实际应用，我们需要基于上述 3 种方式，进一步细化方案。</p><p>上面，为了方便演示，每次传输数据时，只传输动画需要的数据。而实际应用，我们可以需要细化整个传输数据，设定合理的协议。譬如：</p><div class="language-Javascript ext-Javascript line-numbers-mode"><pre class="language-Javascript"><code>Javascript复制代码{\n    // 传输状态：\n    // 1 - 首次传输\n    // 2 - 正常通信\n    // 3 - 页面关闭\n    status: 1 | 2 | 3,\n    data: {}\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>接收方需要基于收到信息所展示的不同的状态，做出不同的反馈。</p><p>当然，还有一个问题，我们如何知道页面被关闭了？基于组件的 <code>onUnmounted</code> 发送当前页面关闭的信息或者基于 window 对象的 <code>beforeunload</code> 事件发送当前页面关闭的信息？</p><p>这些信息都有可能因为 Tab 页面失活，导致关闭的信息无法正常被发送出去。所以，实际应用中，我们经常用的一项技术是<strong>心跳上报/心跳广播</strong>，一旦建立连接后，间隔 X 秒发送一次心跳广播，告诉其他接收端，我还在线。一旦超过某个时间阈值没有收到心跳上报，各个订阅方可以认为该设备已经下线。</p><p>总而言之，跨 Tab 窗口通信应用在实际应用的过程中，我们需要思考更多可能隐藏的问题。</p><h2 id="跨-tab-窗口通信应用场景" tabindex="-1"><a class="header-anchor" href="#跨-tab-窗口通信应用场景" aria-hidden="true">#</a> 跨 Tab 窗口通信应用场景</h2><p>当然，除了最近大火的跨 Tab 动画应用场景，实际业务中，还有许多场景是它可以发挥作用的。这些场景利用了跨 Tab 通信技术，增强了用户体验并提供了更丰富的功能。</p><p>以下是一些常见的应用场景：</p><ol><li>实时协作：多个用户可以在不同的 Tab 页上进行实时协作，比如编辑文档、共享白板、协同编辑等。通过跨Tab通信，可以实现实时更新和同步操作，提高协作效率。</li></ol><p>譬如这个：</p>',16),M=(0,e._)("p",null,[(0,e._)("img",{src:"https://ooszy.cco.vin/img/blog-public/ljz.gif",alt:"img",originSrc:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1089d43faec3419881a68721863368b0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1000&h=517&s=2034662&e=gif&f=141&b=f3f5f7",data:"aurora"})],-1),E=(0,e.uE)('<ol><li>多标签页数据同步：当用户在一个标签页上进行了操作，希望其他标签页上的数据也能实时更新时，可以使用跨 Tab 通信来实现数据同步，保持用户在不同标签页上看到的数据一致性。</li><li>跨标签页通知：在某些场景下，需要向用户发送通知或提醒，即使用户不在当前标签页上也能及时收到。通过跨 Tab 通信，可以实现跨页面的消息传递，向用户发送通知或提醒。</li><li>多标签页状态同步：有些应用可能需要在不同标签页之间同步用户的状态信息，例如登录状态、购物车内容等。通过跨 Tab 通信，可以确保用户在不同标签页上看到的状态信息保持一致。</li><li>页面间数据传输：有时候用户需要从一个页面跳转到另一个页面，并携带一些数据，通过跨Tab通信可以在页面之间传递数据，实现数据的共享和传递。</li></ol><p>举几个实际的例子：</p><ol><li>某系统是一个国际化电商的仓库管理系统，系统能切换到全球各地不同的仓库进行数据操作，当用户打开了页面后，又新开了一个 Tab 页面，并且切换到另外一个仓库进行操作。当用户重新回到第一个打开的页面时，为了防止用户错误操作数据（前端界面是一致的，可能忘记了自己切换过仓库），通过弹窗提醒用户你已经切换过仓库；</li><li>某音乐播放器 PC 页面，在列表页面进行歌曲播放点击，如果当前没有音乐播放详情页，则打开一个新的播放详情页。但是，如果页面已经存在一个音乐播放详情页，则不会打开新的音乐播放详情页，而是直接使用已经存在的播放详情页面；</li><li>系统有与列表页与内容页，在内容页点击已阅，如果用户同时打开了上级列表页，要取消列表页关于该内容页的未读的提示；</li></ol><p>总之，跨 Tab 窗口通信在实时协作、数据同步、通知提醒等方面都能发挥重要作用，为用户提供更流畅、便捷的交互体验。</p><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后" aria-hidden="true">#</a> 最后</h2><p>本文只罗列了 3 种较为常见，适用性强的方式。除去本文罗列的方式，肯定还有其他方式能够实现跨 Tab 通信。</p>',6),A=(0,e.Uk)("譬如，基于 "),x={href:"https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWindow%2Fopener",target:"_blank",rel:"noopener noreferrer"},q=(0,e.Uk)("Window: opener property"),I=(0,e.Uk)(" 配合 "),J=(0,e._)("code",null,"postMessage",-1),F=(0,e.Uk)(" 也可以实现跨 Tab 窗口通信，但是这种通信仅仅适用于当前窗口以及通过当前窗口新开的窗口之间的通信。"),U=(0,e._)("p",null,"来源：https://juejin.cn/post/7306040473542213644",-1),P={},H=(0,a(3744).Z)(P,[["render",function(n,s){const a=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)(e.HY,null,[p,t,l,r,o,c,(0,e._)("p",null,[(0,e._)("a",i,[u,(0,e.Wm)(a)]),b]),d,m,k,g,h,f,v,w,y,j,S,_,B,(0,e._)("p",null,[C,(0,e._)("a",T,[W,(0,e.Wm)(a)])]),z,M,E,(0,e._)("p",null,[A,(0,e._)("a",x,[q,(0,e.Wm)(a)]),I,J,F]),U],64)}]])}}]);